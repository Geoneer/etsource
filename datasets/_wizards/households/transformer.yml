# This is the "data"-file for the households form. Here rules are defined on how 
# we want transform input data from 3rd parties into our "dataset".
# 
# The idea is that we only take care of the actual values/formulas and define all 
# other "fixed" attributes in other files. 


<% 

# --- START Function Definitions ------------------------------------

def section
  :households
end

def input_demand(carrier, carrier_for_application)
  total = (get(section, carrier, :demand_total) * BILLIONS) rescue 0.0
  split = get(section, carrier, :split, carrier_for_application) || 0.0
  val = total * (split / 100)
  val.nan? ? 0.0 : val
end

# ---- Excel function copied --------------------------------------------------
#
# for brevity, if we just pass on arguments, we simply write 'args'
# args: converter_key, input_carrier, output_carrier

# Couldn't we instead use the GQL statement: V(converter_key;output_carrier_output_conversion)? Just an idea...
# -> No: at this moment the GQL is not ready yet. To GQL actually needs the contents of this file to start.
# cell U
def output_conversion(converter_key, input_carrier, output_carrier)
  val("(#{output_carrier})-#{converter_key}", :conversion) # val() looks up from dataset. this looks up a value from export.yml e.g. (hot_water)-hot_water_demand_households_energetic: {conversion: 1.0} 
end

# cell R:
def input_conversion(converter_key, input_carrier, output_carrier)
  val("#{converter_key}-(#{input_carrier})", :conversion) 
end

# cell H
def output_split(converter_key, input_carrier, output_carrier)
  get(section, input_carrier, output_carrier, converter_key) / 100.0 rescue 0.0 
end

# (efficiency between the useful output carrier and the leading input carrier)
# cell K
def effective_efficiency(*args)
  (output_conversion(*args) / input_conversion(*args)) 
end

def input_split(converter_key, input_carrier, output_carrier)
  args = [converter_key, input_carrier, output_carrier]
  h = output_split(*args)
  k = effective_efficiency(*args)

  converter_keys = get(section, input_carrier, output_carrier).keys rescue [] #.keys --> selects the key(s) from the key value pair e.g. "heater_on_oil_households_energetic"=>"100.0" returns heater_on_oil_households_energetic
  sum = converter_keys.map do |key| #.map --> replaces the keys by what's behind the do
     output_split(key, input_carrier, output_carrier) / effective_efficiency(key, input_carrier, output_carrier) 
  end.sum

  (h / k) * (1.0 / sum)
end

# cell J
def input(converter_key, input_carrier, output_carrier)
  i = input_split(converter_key, input_carrier, output_carrier) 
  val = i * input_demand(input_carrier, output_carrier)
  val.nan? ? 0.0 : val # this should already be checked in input_demand. MdH: @Sebi the Not a Number check was only necessary in Excel
  # return of the function is always last number in function
end

# cell L
def output(*args)
  input(*args) * effective_efficiency(*args) 
end

# cell M
def output_share(converter_key, input_carrier, output_carrier)
  args = [converter_key, input_carrier, output_carrier]

  v = output(*args) / sum_of_output(output_carrier)

  v.nan? ? 0.0 : v
end


def sum_of_output(output_carrier)
  # DEBT: memoize this function
  #
  # This represents L90
  #
  # creating the sum is quite tricky indeed...
  #
  # get(section):
  # 
  # {"coal"=>
  #   {"demand_total"=>"0.2",
  #   "split"=>{"useable_heat"=>"100.0", "hot_water"=>"0.0"},
  #   "useable_heat"=>{"heater_on_coal_households_energetic"=>"100.0"},
  #   "hot_water"=>{"coal_boiler_households_energetic"=>"100.0"}},
  # "crude_oil"=>
  #  {"demand_total"=>"3.8",
  #   "split"=>{"useable_heat"=>"100.0", "hot_water"=>"0.0"},
  #   "useable_heat"=>{"heater_on_oil_households_energetic"=>"100.0"},
  #   "hot_water"=>{"oil_boiler_households_energetic"=>"100.0"}},
  #
  # What we want is (for input_carrier: useable_heat): 
  #
  # => heater_on_coal_households_energetic, useable_heat, coal
  # => heater_on_oil_households_energetic, useable_heat, crude_oil
  sum = 0
  input_carriers = keys_that_contain(section, output_carrier)
  input_carriers.each do |_input_carrier|
    converter_keys = get(section, _input_carrier, output_carrier).keys rescue []
    converter_keys.each do |_converter|
      sum += output(_converter, _input_carrier, output_carrier)
    end
  end
  sum
end

# cell N
def expected_demand(*args)
  input(*args) / input_conversion(*args) 
end

def ambient_heat_consumption(converter, carrier)
  v = input(converter.to_sym, carrier, :useable_heat) 
  v = v / input_conversion(converter.to_sym, carrier, :useable_heat)
  v = v * input_conversion(converter.to_sym, :ambient_heat, :useable_heat)
  v
end


# --- END Function Definitions ------------------------------------





# --- demand_expected_value -------------------------------

# Generate demand_expected_values for all the household converters.
# This values are mostly for the researchers to debug and do not change
# the calculation.
wizard_config[:households].each do |application_carrier, carrier_converters|
  carrier_converters.each do |carrier, converters|
    converters.each do |converter| 
      attrs = [converter.to_sym, carrier, application_carrier]
      # Do not intend YAML lines, this would screw up the yaml structure
%>

:<%= converter %>:
  # expected demand. thus not influence graph calculation
  demand_expected_value: <%= expected_demand(*attrs) %>
  <% if (wizard_config[:ambient_heat][application_carrier][carrier].include?(converter) rescue false) %>
  ambient_heat_input: <%= ambient_heat_consumption(converter, carrier) rescue 'Error' %>
  <% end %>
  # -- adding results of helper calculations to converter, so we can debug values
  # prepend names with debug_ so they will not mess up with other attributes
  debug_output_split: <%= output_split(*attrs) %>
  debug_input_demand:  <%= input_demand(carrier, application_carrier) %>
  debug_input_split:  <%= input_split(converter.to_sym, carrier, application_carrier) %>
  debug_input:        <%= input(converter.to_sym, carrier, application_carrier) %>
  debug_effective_efficiency:  <%= effective_efficiency(converter.to_sym, carrier, application_carrier) %>
  debug_output:       <%= output(converter.to_sym, carrier, application_carrier) %>
  debug_output_share: <%= output_share(converter.to_sym, carrier, application_carrier) %>
  

<%
    end # converters
  end # carrier_converters
end # wizard_config[:households]
%>

# --- Assign values to link shares ------------------------------------
# In output_shares we define the "parent" converters for each application referenced
# by the carrier. Iterate through all applications defined, then create a link
# for every converter of that application.

<% 
wizard_config[:application_parents].each do |application_carrier, left_converter| %>

# --- Application Parents with links ----------------------------------

:<%= left_converter %>:
  :demand_expected_value: <%= sum_of_output(application_carrier)  %>
  
<%
  wizard_config[:households][application_carrier].each do |carrier, converters|
    converters.each do |converter| %> 

<%= "#{left_converter}-(#{application_carrier}) -- s --> (#{application_carrier})-#{converter}" %>:
  share: <%= output_share(converter.to_sym, carrier, application_carrier) %>
  
<%  end # carrier_converters
  end # wizard_config[:households][application_carrier]
end # wizard_config[:households] %>

# --- HOT WATER SPLIT -----

<% hot_water_total = sum_of_output(:hot_water) + input_demand(:solar_thermal, :hot_water) %>

:hot_water_demand_households_energetic:
  :expected_demand: <%= hot_water_total %>

hot_water_demand_households_energetic-(hot_water) -- s --> (hot_water)-hot_water_devices_households_energetic: 
  share: <%= sum_of_output(:hot_water) / hot_water_total %>

:solar_panel_for_hot_water_households_energetic:
  :expected_demand: <%= input_demand(:solar_thermal, :hot_water) %>

hot_water_demand_households_energetic-(hot_water) -- s --> (hot_water)-solar_panel_for_hot_water_households_energetic: 
  share: <%= input_demand(:solar_thermal, :hot_water) / hot_water_total %>


