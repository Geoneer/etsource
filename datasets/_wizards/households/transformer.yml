# This is the "data"-file for the households form. Here rules are defined on how 
# we want transform input data from 3rd parties into our "dataset".
# 
# The idea is that we only take care of the actual values/formulas and define all 
# other "fixed" attributes in other files. 

<% 
section = :households

total_of_carrier = lambda do |key|
  (get(section, key, :demand_total, default: 0.0) * BILLIONS) rescue 0.0
end

input_demand = lambda do |key1,key2| 
  total = (get(section, key1, :demand_total) * BILLIONS) rescue 0.0
  split = get(section, key1, :split, key2) || 0.0
  val = total * (split / 100)
  val.nan? ? 0.0 : val
end


#
# ---- Excel function copied --------------------------------------------------
#
# for brevity, if we just pass on arguments, we simply write 'args'
# args: converter_key, input_carrier, output_carrier

cell_u = lambda do |converter_key, input_carrier, output_carrier|
  val("(#{output_carrier})-#{converter_key}", :conversion) 
end

cell_r = lambda do |converter_key, input_carrier, output_carrier|
  val("#{converter_key}-(#{input_carrier})", :conversion) 
end

cell_h = lambda do |converter_key, input_carrier, output_carrier|
  get(section, input_carrier, output_carrier, converter_key) / 100.0 rescue 0.0 
end

# Cell K
cell_k = lambda { |*args| (cell_u.call(*args) / cell_r.call(*args)) }

# Cell I # the individual split / whatever
cell_i = lambda do |converter_key, input_carrier, output_carrier|
  args = [converter_key, input_carrier, output_carrier]
  h = cell_h.call(*args)
  k = cell_k.call(*args)

  converter_keys = get(section, input_carrier, output_carrier).keys rescue []
  sum = converter_keys.map do |key|
     cell_h.call(key, input_carrier, output_carrier) / cell_k.call(key, input_carrier, output_carrier) 
  end.sum

  (h / k) * (1.0 / sum)
end

# Cell J (input)
cell_j = lambda do |converter_key, input_carrier, output_carrier|
  i = cell_i.call(converter_key, input_carrier, output_carrier) 
  val = i * input_demand.call(input_carrier, output_carrier)
  val.nan? ? 0.0 : val # this should already be checked in input_demand.
end

cell_l = lambda { |*args| cell_j.call(*args) * cell_k.call(*args) }

cell_m = lambda do |converter_key, input_carrier, output_carrier|
  args = [converter_key, input_carrier, output_carrier]
  
  converter_keys = get(section, input_carrier, output_carrier).keys rescue []
  sum = converter_keys.map do |key|
     cell_l.call(key, input_carrier, output_carrier) / cell_k.call(key, input_carrier, output_carrier) 
  end.sum

  v = cell_l.call(*args) / sum

  v.nan? ? 0.0 : v
end

cell_n = lambda { |*args| cell_j.call(*args) / cell_r.call(*args) }

%>

# ---- Section: Final Demand --------------------------------------------------

:steam_hot_water_households_energetic: 
  :demand_expected_value: <%= total_of_carrier.call(:hot_water) %>
  
:heat_from_steam_hot_water_households_energetic: 
  :demand_expected_value: <%= input_demand.call(:hot_water, :hot_water) %>

:monitized_heat_for_hot_water_households_energetic: 
  :demand_expected_value: <%= input_demand.call(:hot_water, :hot_water) %>

<% 
# Do not intend YAML lines, this would screw up the yaml structure
Etsource::Constants::HOUSEHOLDS.each do |section_carrier, carrier_converters| %>

# ----- Section #{section_carrier} ----------------------------

  <% carrier_converters.each do |carrier, converters| %>
    <% converters.each do |converter| %>
:<%= converter %>:
  :demand_expected_value: <%= cell_n.call(converter.to_sym, carrier, section_carrier)  %>
  # ------ this are for debugging purposes only -----------
  # you can see this values when you click on the debug button in the forms view.
  # they are "stored" in the dataset, and can be retrieved like:
  #
  #     Current.gql.present_graph.converter(__key__).object_dataset[:__attr_key__]
  :output_share:  <%= cell_m.call(converter.to_sym, carrier, section_carrier) %>
  :cell_h:  <%= cell_h.call(converter.to_sym, carrier, section_carrier) %>
  :cell_i:  <%= cell_i.call(converter.to_sym, carrier, section_carrier) %>
  :cell_j:  <%= cell_j.call(converter.to_sym, carrier, section_carrier) %>
  :cell_k:  <%= cell_k.call(converter.to_sym, carrier, section_carrier) %>
  :cell_l:  <%= cell_u.call(converter.to_sym, carrier, section_carrier) %>
    <% end %>
  <% end %>
<% end %>
