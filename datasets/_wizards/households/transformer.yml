# This is the "data"-file for the households form. Here rules are defined on how 
# we want transform input data from 3rd parties into our "dataset".
# 
# The idea is that we only take care of the actual values/formulas and define all 
# other "fixed" attributes in other files. 


<% 
section = :households

input_demand = lambda do |carrier, carrier_for_application|
  total = (get(section, carrier, :demand_total) * BILLIONS) rescue 0.0
  split = get(section, carrier, :split, carrier_for_application) || 0.0
  val = total * (split / 100)
  val.nan? ? 0.0 : val
end

# ---- Excel function copied --------------------------------------------------
#
# for brevity, if we just pass on arguments, we simply write 'args'
# args: converter_key, input_carrier, output_carrier

# Couldn't we instead use the GQL statement: V(converter_key;output_carrier_output_conversion)? Just an idea...
# -> No: at this moment the GQL is not ready yet. To GQL actually needs the contents of this file to start.
cell_u = output_conversion = lambda do |converter_key, input_carrier, output_carrier|
  val("(#{output_carrier})-#{converter_key}", :conversion) # val() looks up from dataset. this looks up a value from export.yml e.g. (hot_water)-hot_water_demand_households_energetic: {conversion: 1.0} 
end

cell_r = input_conversion = lambda do |converter_key, input_carrier, output_carrier|
  val("#{converter_key}-(#{input_carrier})", :conversion) 
end

cell_h = output_split = lambda do |converter_key, input_carrier, output_carrier|
  get(section, input_carrier, output_carrier, converter_key) / 100.0 rescue 0.0 
end

# (efficiency between the useful output carrier and the leading input carrier)
cell_k = effective_efficiency = lambda do |*args| 
  (cell_u.call(*args) / cell_r.call(*args)) 
end

cell_i = input_split = lambda do |converter_key, input_carrier, output_carrier|
  args = [converter_key, input_carrier, output_carrier]
  h = cell_h.call(*args)
  k = cell_k.call(*args)

  converter_keys = get(section, input_carrier, output_carrier).keys rescue [] #.keys --> selects the key(s) from the key value pair e.g. "heater_on_oil_households_energetic"=>"100.0" returns heater_on_oil_households_energetic
  sum = converter_keys.map do |key| #.map --> replaces the keys by what's behind the do
     cell_h.call(key, input_carrier, output_carrier) / cell_k.call(key, input_carrier, output_carrier) 
  end.sum

  (h / k) * (1.0 / sum)
end

# Cell J: Input
cell_j = lambda do |converter_key, input_carrier, output_carrier|
  i = cell_i.call(converter_key, input_carrier, output_carrier) 
  val = i * input_demand.call(input_carrier, output_carrier)
  val.nan? ? 0.0 : val # this should already be checked in input_demand. MdH: @Sebi the Not a Number check was only necessary in Excel
  # return of the function is always last number in function
end

# Cell L: Ouput
cell_l = lambda { |*args| cell_j.call(*args) * cell_k.call(*args) }

cell_m = output_share = lambda do |converter_key, input_carrier, output_carrier|
  args = [converter_key, input_carrier, output_carrier]

  # creating the sum is quite tricky indeed...
  #
  # get(section):
  # 
  # {"coal"=>
  #   {"demand_total"=>"0.2",
  #   "split"=>{"useable_heat"=>"100.0", "hot_water"=>"0.0"},
  #   "useable_heat"=>{"heater_on_coal_households_energetic"=>"100.0"},
  #   "hot_water"=>{"coal_boiler_households_energetic"=>"100.0"}},
  # "crude_oil"=>
  #  {"demand_total"=>"3.8",
  #   "split"=>{"useable_heat"=>"100.0", "hot_water"=>"0.0"},
  #   "useable_heat"=>{"heater_on_oil_households_energetic"=>"100.0"},
  #   "hot_water"=>{"oil_boiler_households_energetic"=>"100.0"}},
  #
  # What we want is (for input_carrier: useable_heat): 
  #
  # => heater_on_coal_households_energetic, useable_heat, coal
  # => heater_on_oil_households_energetic, useable_heat, crude_oil

  # MdH: would be useful to be able to acces the sum function outside of 'cell_m' as it is also used for expected demand of parent converter

  sum = 0
  input_carriers = keys_that_contain(section, output_carrier)
  input_carriers.each do |_input_carrier|
    converter_keys = get(section, _input_carrier, output_carrier).keys rescue []
    converter_keys.each do |_converter|
      sum += cell_l.call(_converter, _input_carrier, output_carrier)
    end
  end

  v = cell_l.call(*args) / sum

  v.nan? ? 0.0 : v
end

cell_n = expected_demand = lambda do |*args| 
  cell_j.call(*args) / cell_r.call(*args) 
end

%>

<% 
# Generate demand_expected_values for all the household converters.
# This values are mostly for the researchers to debug and do not change
# the calculation.

# Assign demand expected value
wizard_config[:households].each do |section_carrier, carrier_converters|
  carrier_converters.each do |carrier, converters|
    converters.each do |converter| 
      # Do not intend YAML lines, this would screw up the yaml structure
%>

:<%= converter %>:
  :demand_expected_value: <%= cell_n.call(converter.to_sym, carrier, section_carrier)  %>
  # - debug ---
  :output_share:  <%= cell_m.call(converter.to_sym, carrier, section_carrier) %>
  :cell_h:  <%= cell_h.call(converter.to_sym, carrier, section_carrier) %>
  :cell_i:  <%= cell_i.call(converter.to_sym, carrier, section_carrier) %>
  :cell_j:  <%= cell_j.call(converter.to_sym, carrier, section_carrier) %>
  :cell_k:  <%= cell_k.call(converter.to_sym, carrier, section_carrier) %>
  :cell_l:  <%= cell_l.call(converter.to_sym, carrier, section_carrier) %>
  :cell_m:  <%= cell_m.call(converter.to_sym, carrier, section_carrier) %>
    
<%
    end # converters.each
  end # carrier_converters.each
end # Etsource::Constants::HOUSEHOLDS.each 
%>

# Assign values to link shares
<% 
wizard_config['output_shares'].each do |application_carrier, left_converter|
  wizard_config[:households][application_carrier].each do |carrier, converters|
    converters.each do |converter|
%> 
<%= "#{left_converter}-(#{application_carrier}) -- s --> (#{application_carrier})-#{converter}:" %> 
  share: <%= cell_m.call(converter.to_sym, carrier, application_carrier) %>
<%
    end # carrier_converters.each
  end # wizard_config[:households][application_carrier].each
end # Etsource::Constants::HOUSEHOLDS_HEATING.each 
%>
