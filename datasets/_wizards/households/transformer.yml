# This is the "data"-file for the households form. Here rules are defined on how 
# we want transform input data from 3rd parties into our "dataset".
# 
# The idea is that we only take care of the actual values/formulas and define all 
# other "fixed" attributes in other files. 

<% 
section = :households

# A better name would be: final_energy_consumption
total_of_carrier = lambda do |key|
  (get(section, key, :demand_total, default: 0.0) * BILLIONS) rescue 0.0
end

# A better name would be: 'carrier_for_application' as the associated converters are called, e.g. coal_for_heating
input_demand = lambda do |key1,key2| # key1 = carrier, key2=application (but named by the useful carrier)
  total = (get(section, key1, :demand_total) * BILLIONS) rescue 0.0
  split = get(section, key1, :split, key2) || 0.0
  val = total * (split / 100)
  val.nan? ? 0.0 : val
end

# ---- Excel function copied --------------------------------------------------
#
# for brevity, if we just pass on arguments, we simply write 'args'
# args: converter_key, input_carrier, output_carrier

# MdH: @Sebi: Wouldn't it be much more readable to replace the 'Cell X' functions by the name of the column, e.g. 'Output conversion'?

# Cell U: Output conversion
# Couldn't we instead use the GQL statement: V(converter_key;output_carrier_output_conversion)? Just an idea...
cell_u = lambda do |converter_key, input_carrier, output_carrier|
  val("(#{output_carrier})-#{converter_key}", :conversion) # val() looks up from dataset. this looks up a value from export.yml e.g. (hot_water)-hot_water_demand_households_energetic: {conversion: 1.0} 
end

# Cell R: Input conversion
cell_r = lambda do |converter_key, input_carrier, output_carrier|
  val("#{converter_key}-(#{input_carrier})", :conversion) 
end

# Cell H: Output split
# Does this work? What is the value it looks up?
cell_h = lambda do |converter_key, input_carrier, output_carrier|
  get(section, input_carrier, output_carrier, converter_key) / 100.0 rescue 0.0 # get() looks up from form
end

# Cell K: Effective efficiency (efficiency between the useful output carrier and the leading input carrier)
cell_k = lambda { |*args| (cell_u.call(*args) / cell_r.call(*args)) }

# Cell I: Input split
cell_i = lambda do |converter_key, input_carrier, output_carrier|
  args = [converter_key, input_carrier, output_carrier]
  h = cell_h.call(*args)
  k = cell_k.call(*args)

  converter_keys = get(section, input_carrier, output_carrier).keys rescue [] #.keys --> selects the key(s) from the key value pair e.g. "heater_on_oil_households_energetic"=>"100.0" returns heater_on_oil_households_energetic
  sum = converter_keys.map do |key| #.map --> replaces the keys by what's behind the do
     cell_h.call(key, input_carrier, output_carrier) / cell_k.call(key, input_carrier, output_carrier) 
  end.sum

  (h / k) * (1.0 / sum)
end

# Cell J: Input
cell_j = lambda do |converter_key, input_carrier, output_carrier|
  i = cell_i.call(converter_key, input_carrier, output_carrier) 
  val = i * input_demand.call(input_carrier, output_carrier)
  val.nan? ? 0.0 : val # this should already be checked in input_demand. MdH: @Sebi the Not a Number check was only necessary in Excel
  # return of the function is always last number in function
end

# Cell L: Ouput
cell_l = lambda { |*args| cell_j.call(*args) * cell_k.call(*args) }

# Cell M: Output share
cell_m = lambda do |converter_key, input_carrier, output_carrier|
  args = [converter_key, input_carrier, output_carrier]
  

  # creating the sum is quite tricky indeed...
  #
  # get(section):
  # 
  # {"coal"=>
  #   {"demand_total"=>"0.2",
  #   "split"=>{"useable_heat"=>"100.0", "hot_water"=>"0.0"},
  #   "useable_heat"=>{"heater_on_coal_households_energetic"=>"100.0"},
  #   "hot_water"=>{"coal_boiler_households_energetic"=>"100.0"}},
  # "crude_oil"=>
  #  {"demand_total"=>"3.8",
  #   "split"=>{"useable_heat"=>"100.0", "hot_water"=>"0.0"},
  #   "useable_heat"=>{"heater_on_oil_households_energetic"=>"100.0"},
  #   "hot_water"=>{"oil_boiler_households_energetic"=>"100.0"}},
  #
  # What we want is (for input_carrier: useable_heat): 
  #
  # => heater_on_coal_households_energetic, useable_heat, coal
  # => heater_on_oil_households_energetic, useable_heat, crude_oil

  # MdH: would be useful to be able to acces the sum function outside of 'cell_m' as it is also used for expected demand of parent converter

  sum = 0
  input_carriers = keys_that_contain(section, output_carrier)
  input_carriers.each do |_input_carrier|
    converter_keys = get(section, _input_carrier, output_carrier).keys rescue []
    converter_keys.each do |_converter|
      sum += cell_l.call(_converter, _input_carrier, output_carrier)
    end
  end

  v = cell_l.call(*args) / sum

  v.nan? ? 0.0 : v
end

# Cell N: expected demand 
cell_n = lambda { |*args| cell_j.call(*args) / cell_r.call(*args) }

%>

<% 
# Generate demand_expected_values for all the household converters.
# This values are mostly for the researchers to debug and do not change
# the calculation.

# Assign demand expected value
Etsource::Constants::HOUSEHOLDS.each do |section_carrier, carrier_converters|  
  carrier_converters.each do |carrier, converters|
    converters.each do |converter| 
      # Do not intend YAML lines, this would screw up the yaml structure
%>

:<%= converter %>:
  :demand_expected_value: <%= cell_n.call(converter.to_sym, carrier, section_carrier)  %>
  # - debug ---
  :output_share:  <%= cell_m.call(converter.to_sym, carrier, section_carrier) %>
  :cell_h:  <%= cell_h.call(converter.to_sym, carrier, section_carrier) %>
  :cell_i:  <%= cell_i.call(converter.to_sym, carrier, section_carrier) %>
  :cell_j:  <%= cell_j.call(converter.to_sym, carrier, section_carrier) %>
  :cell_k:  <%= cell_k.call(converter.to_sym, carrier, section_carrier) %>
  :cell_l:  <%= cell_l.call(converter.to_sym, carrier, section_carrier) %>
  :cell_m:  <%= cell_m.call(converter.to_sym, carrier, section_carrier) %>
    
<%
    end # converters.each
  end # carrier_converters.each
end # Etsource::Constants::HOUSEHOLDS.each 
%>

# Assign values to link shares
<% 
Etsource::Constants::HOUSEHOLDS_HEATING.each do |carrier, converters|
  converters.each do |converter| 
%> 
heating_demand_households_energetic-(useable_heat) -- s --> (useable_heat)-electric_heater_households_energetic: 
  share: <%= cell_m.call(converter.to_sym, carrier, :useable_heat) %>
<%
  end # converters.each
end # Etsource::Constants::HOUSEHOLDS_HEATING.each 
%>