# This is the "data"-file for the households form. Here rules are defined on how 
# we want transform input data from 3rd parties into our "dataset".
# 
# The idea is that we only take care of the actual values/formulas and define all 
# other "fixed" attributes in other files. 
#
#
# == A Limitation of yaml
#
# Be careful not to accidentaly overwrite key, value pairs within a .yml file.
#
#     converter_key_1:
#       demand: 300
#       â€¦
#
# and then at a later point
#
#     converter_key_1:
#       output_share: 0.4
#
# The second definition simply overwrites the first. It does not merge them, so "demand" 
# is lost. This is how yaml works and cannot be changed in a trivial matter. When I added 
# the ambient heat calculation I accidentally made above mistake :(. Fixed now.
#
# However, if the two definitions are spread out in two different files, this would work, 
# because our import script merges the definitions (much like with the defaults and 
# country datasets). 
#
# So if this becomes a problem, I could change the import script to allow for more 
# transformers. But I leave it for now, so we don't have to introduce extra-complexity. 

<% 

# --- START Function Definitions ------------------------------------

def section
  :households
end

# I have renamed:
# carrier_for_application --> application_carrier
# input_demand --> carrier_for_application
# Furthermore I suggest to write down a comment for each function that shows the units (Unit: 1 means dimensionless)

# Final energy consumption for a specific application. Unit: MJ
# Excel range N45:U50
def carrier_for_application(carrier, application_carrier)
  total = (get(section, carrier, :demand_total) * BILLIONS) rescue 0.0
  split = get(section, carrier, :split, application_carrier) || 0.0
  val = total * (split / 100)
  val.nan? ? 0.0 : val
end

# ---- Excel function copied --------------------------------------------------
#
# for brevity, if we just pass on arguments, we simply write 'args'
# args: converter_key, input_carrier, output_carrier

# Conversion of output slot. Unit: 1
# Excel column U
def output_conversion(converter_key, input_carrier, output_carrier)
  val(:graph, "(#{output_carrier})-#{converter_key}", :conversion) # val() looks up from dataset. this looks up a value from export.yml e.g. (hot_water)-hot_water_demand_households_energetic: {conversion: 1.0} 
end

# Conversion of input slot. Unit: 1
# Excel column R:
def input_conversion(converter_key, input_carrier, output_carrier)
  val(:graph, "#{converter_key}-(#{input_carrier})", :conversion) 
end

# Effective efficiency between the useful output carrier and the leading input carrier. Note: called effective because it can be >1 for heatpumps. Unit: 1
# Excel column K
def effective_efficiency(*args)
  (output_conversion(*args) / input_conversion(*args)) 
end

# Split of useful output energy relative to sum of converters on same (leading) input carrier. Unit: 1
# Excel column H
def output_split(converter_key, input_carrier, output_carrier)
  get(section, input_carrier, output_carrier, converter_key) / 100.0 rescue 0.0 
end

# Split of (leading) input energy relative to sum of converters on same (leading) input carrier. Unit: 1
# Excel column I
def input_split(converter_key, input_carrier, output_carrier)
  args = [converter_key, input_carrier, output_carrier]
  h = output_split(*args)
  k = effective_efficiency(*args)

  converter_keys = get(section, input_carrier, output_carrier).keys rescue [] #.keys --> selects the key(s) from the key value pair e.g. "heater_on_oil_households_energetic"=>"100.0" returns heater_on_oil_households_energetic
  sum = converter_keys.map do |key| #.map --> replaces the keys by what's behind the do
     output_split(key, input_carrier, output_carrier) / effective_efficiency(key, input_carrier, output_carrier) 
  end.sum

  (h / k) * (1.0 / sum)
end

# Input of energy (from leading carrier). Unit: MJ
# Excel column J
def input(converter_key, input_carrier, output_carrier)
  i = input_split(converter_key, input_carrier, output_carrier) 
  val = i * carrier_for_application(input_carrier, output_carrier)
  val.nan? ? 0.0 : val # this should already be checked in carrier_for_application. MdH: @Sebi the Not a Number check was only necessary in Excel
  # return of the function is always last number in function
end

# Useful output energy. Unit: MJ
# Excel column L
def output(*args)
  input(*args) * effective_efficiency(*args) 
end

# Share of useful output energy relative to sum of converters that supply the same left converter. Unit: 1
# Excel column M
def output_share(converter_key, input_carrier, output_carrier)
  args = [converter_key, input_carrier, output_carrier]

  v = output(*args) / sum_of_output(output_carrier)

  v.nan? ? 0.0 : v
end

# Total useful energy output that supplies the same left converter. Unit: MJ
def sum_of_output(output_carrier)
  # DEBT: memoize this function
  #
  # This represents L90
  #
  # creating the sum is quite tricky indeed...
  #
  # get(section):
  # 
  # {"coal"=>
  #   {"demand_total"=>"0.2",
  #   "split"=>{"useable_heat"=>"100.0", "hot_water"=>"0.0"},
  #   "useable_heat"=>{"heater_on_coal_households_energetic"=>"100.0"},
  #   "hot_water"=>{"coal_boiler_households_energetic"=>"100.0"}},
  # "crude_oil"=>
  #  {"demand_total"=>"3.8",
  #   "split"=>{"useable_heat"=>"100.0", "hot_water"=>"0.0"},
  #   "useable_heat"=>{"heater_on_oil_households_energetic"=>"100.0"},
  #   "hot_water"=>{"oil_boiler_households_energetic"=>"100.0"}},
  #
  # What we want is (for input_carrier: useable_heat): 
  #
  # => heater_on_coal_households_energetic, useable_heat, coal
  # => heater_on_oil_households_energetic, useable_heat, crude_oil
  sum = 0
  input_carriers = keys_that_contain(section, output_carrier)
  input_carriers.each do |_input_carrier|
    converter_keys = get(section, _input_carrier, output_carrier).keys rescue []
    converter_keys.each do |_converter|
      sum += output(_converter, _input_carrier, output_carrier)
    end
  end
  sum
end

# Expected demand. Unit: MJ
# Excel column N
def expected_demand(*args)
  input(*args) / input_conversion(*args) 
end

# Ambient heat consumption of heatpumps. Unit: MJ
# Excel column J (only selection of rows)
def ambient_heat_consumption(converter, application_carrier, carrier)
  v = input(converter.to_sym, application_carrier, carrier) 
  v = v / input_conversion(converter.to_sym, application_carrier, carrier)
  v = v * input_conversion(converter.to_sym, :ambient_heat, carrier)
  v
end


# --- END Function Definitions ------------------------------------

# --- demand_expected_value -------------------------------

# Generate demand_expected_values for all the household converters.
# This values are mostly for the researchers to debug and do not change
# the calculation.
wizard_config[:households].each do |application, config|
  application_carrier = config[:carrier]
  carrier_converters  = config[:section]

  carrier_converters.each do |carrier, converters|
    converters.each do |converter| 
      attrs = [converter.to_sym, carrier, application_carrier]
      # Do not intend YAML lines, this would screw up the yaml structure
%>

graph:
  :<%= converter %>:
    # expected demand. thus not influence graph calculation
    demand_expected_value: <%= expected_demand(*attrs) %>
    <% if (wizard_config[:ambient_heat][application][carrier].include?(converter) rescue false) %>
    ambient_heat_input: <%= ambient_heat_consumption(converter, carrier, application_carrier) %>
    <% end %>
    # -- adding results of helper calculations to converter, so we can debug values
    # prepend names with debug_ so they will not mess up with other attributes
    debug_output_split: <%= output_split(*attrs) %>
    debug_carrier_for_application:  <%= carrier_for_application(carrier, application_carrier) %>
    debug_input_split:  <%= input_split(converter.to_sym, carrier, application_carrier) %>
    debug_input:        <%= input(converter.to_sym, carrier, application_carrier) %>
    debug_effective_efficiency:  <%= effective_efficiency(converter.to_sym, carrier, application_carrier) %>
    debug_output:       <%= output(converter.to_sym, carrier, application_carrier) %>
    debug_output_share: <%= output_share(converter.to_sym, carrier, application_carrier) %>

<%
    end # converters
  end # carrier_converters
end # wizard_config[:households]
%>

# --- Assign values to link shares ------------------------------------
# In output_shares we define the "parent" converters for each application referenced
# by the carrier. Iterate through all applications defined, then create a link
# for every converter of that application.
<% 
wizard_config[:households].each do |application, config|
  config[:parents].each do |application_carrier, left_converter| %>

  # --- Application Parents with links ----------------------------------
graph:
  :<%= left_converter %>:
    :demand_expected_value: <%= sum_of_output(application_carrier)  %>
  
  <%
  config[:section].each do |carrier, converters|
    converters.each do |converter| %> 

  <%= "#{left_converter}-(#{application_carrier}) -- s --> (#{application_carrier})-#{converter}" %>:
    share: <%= output_share(converter.to_sym, carrier, application_carrier) %>
  
<%    end # converters
    end # wizard_config[:households][application][:section]
  end # config[:parents]
end # wizard_config[:households] %>

# --- HOT WATER SPLIT -----

# MdH: HELP!! Now the use of :hot_water becomes very confusing "sum_of_output(:hot_water)"  
# I would expect to result in the value in cell L131, but it does give the value in cell L126. Which is correct here, just very confusing. Can we think of a smarter way? Maybe refer to the converter which demands the sum (hot_water_devices for L126, hot_water_demand_HH for L131)?
<% hot_water_total = sum_of_output(:hot_water) + carrier_for_application(:solar_thermal, :hot_water) %>
graph:
  :hot_water_demand_households_energetic:
    :expected_demand: <%= hot_water_total %>

  hot_water_demand_households_energetic-(hot_water) -- s --> (hot_water)-hot_water_devices_households_energetic: 
    share: <%= sum_of_output(:hot_water) / hot_water_total %>

  :solar_panel_for_hot_water_households_energetic:
    :expected_demand: <%= carrier_for_application(:solar_thermal, :hot_water) %>

  hot_water_demand_households_energetic-(hot_water) -- s --> (hot_water)-solar_panel_for_hot_water_households_energetic: 
    share: <%= carrier_for_application(:solar_thermal, :hot_water) / hot_water_total %>


