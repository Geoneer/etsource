Folder structure
================

inputs
-------

gqueries
---------
Gqueries nested within folders. The folders names are concatenated and become the group of a gquery. E.g. The gquery co2 defined in: /gqueries/foo/bar/co2.yml will be assigned to the gquery_group 'foo_bar'.

scripts
--------
The folder 'scripts' contains the scripts used to alter the names and contents of the queries.
The folder 'change_reports' within 'scripts' contains the changes made in the queries, one for each of the query groups.

Rules and best practices
------------------------
Try to make one commit for each batch of changes you make to the files, related to one issue.
For example, if a query is changed, try to alter all queries and inputs related to the query in a single commit.


# ETsource Form Wizards from the Bottom up

## Glossary

_virtual_: things that are not stored in this github project are called virtual. 

## A) Data Bucket

Is a collection of (nested) key-value pairs. It is either stored in a file and commited to Github, or it is a virtual one, such as the ones generated by the _form wizard_, and just exists while loading the Etsource. 

### Key Value Pair

_Key_ is the name of the attribute and value the actual value. The value can be a number, boolean, text, date. Inside a _transformer definition_ (_dataset wizard_) the value can be also a dynamic, calculated one. 

    :co2_price: 0.125
    :co2_price: <%= 5.0 * 1.25 / 1_000_000 %>

The key will sometimes be written with or without trailing ":". This is the case in data buckets for topology elements.

### Nested Key Value Pairs and namespaces.

To separate key value pairs we can nest them, and create a folder structure.

    :carriers:
      :electricity:
        :infinite: false

General guidelines is that the top-level "folder" contains sections for every type of graph element and are called _namespaces_.

    :carriers:
    :area:
      :area_data:

Exceptions are the elements defined in the _topology_, they have an implicit nesting, based on how they _key_ looks like. 

We can also write a nested key value pair in one line, now this can be found for slot and link key-value pairs:
    
    hot_water_demand_households_energetic-(hot_water): {conversion: 1.0}

#### Implicit nesting

Elements defined in the _topology_, like _converters_, _links_ and _slots_ have an implicit nesting, determined by their _key_. 

    hot_water_demand_households_energetic:
    # => will at runtime be moved into a :converters: namespace
    :converters:
      hot_water_demand_households_energetic:

For elements that have implicit nesting, it is required that the namespaces are omitted.


## B) Datasets

A dataset is the collection of all _data buckets_ within a _section_. Look at it as one big _data bucket_. A dataset is virtual, and not commited to Github. The merging of all buckets happens during runtime. There are three independent levels: default, country and wizard datasets. Each can overwrite values of the former. 

### Default Dataset (datasets/_defaults)

Contains all the values that are a) the same for every country or b) should be treated as default/start values. Values here are overwritten in the country dataset. That means we can put the data that sometimes changes in a _default dataset_ and overwrite it in the _country dataset_ when it does actually change.

### Country Dataset (datasets/:area_code)

The precise name would be area(-specific) dataset (area can be a country 'nl', or a region 'nl-drenthe'). But country dataset is a clear enough and human-friendly name and is easy on the lips.

### Wizard Dataset

Is the dataset generated by a dataset wizard transformer (see that section for details).

### Graph Dataset

The Graph dataset merges the default, country, wizard dataset together to the final dataset. It contains everything that is needed for a country (including time series, fce_values, area data).

### Overwriting Rules

```yml

# _defaults/area.yml
...
:area_data:
  :co2_price: 0.002
  :has_fce: false

# nl/area.yml
...
:area_data:
  :number_of_households: 100_000
  :has_fce: true

# => {:area_data: {:co2_price: 0.002, :number_of_households: 100_000, :has_fce: true }}

```

### Mixins

The purpose of a mixin is to summarize key value pairs that are often found together under a certain context. Hard to explain, easy to show:

```yml

# mixin:
:peak_load_normal: &peak_load_normal
  :simult_sd: 1.0
  :simult_se: 1.0
  :simult_wd: 1.0
  :simult_we: 1.0

:waste_incinerator_energy_energetic:
  << *peak_load_normal
  :simult_we: 0.5 # make an exception for simult_we

# Generates:

:waste_incinerator_energy_energetic:
  :simult_sd: 1.0
  :simult_se: 1.0
  :simult_wd: 1.0
  :simult_we: 0.5

```

## C) Dataset Wizard

Dataset wizard (former dynamic dataset)
As of now a wizard consists of a form (what you see) and a transformer (the magic glue). When you apply a research dataset (what you enter) the transformer creates a wizard data bucket (what you get). 
- Form
- Transformer
- Transformer + Research Dataset generates:
-> wizard data bucket (they are virtual = not stored in a file, only in the memory).

